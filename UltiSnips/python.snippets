priority 50

# mysnippets
snippet importtorch "the basic import for pytorch" b
import torch
import torch.nn as nn
import torchvision
import mmcv
import numpy as np

$0
endsnippet

snippet importpath "quit import path" b
from libpath import Path
$0
endsnippet

snippet torchmodel "the model for torch"
class ${1:Modulename}(torch.nn.Module):

	def __init__(self,):
		super($1,self).__init__()

	def forward(self,):
		pass
		$0

endsnippet

snippet mmcvimg "mmcv image operations"

img = mmcv.imread($1) # read as numpy
# mmcv.imwrite(img, 'out.jpg') # write image
# mmcv.imshow(img, win_name='test image', wait_time=200)

endsnippet

snippet mmcvvideo "mmcv video operations" b

video = mmcv.VideoReader($1)

# video meta data
# width=video.width
# height=video.height
# resolution=video.resolution
# fps=video.fps

# video.cvt2frames('out_dir')
# mmcv.frames2video('out_dir', 'test.avi') # generate video from frames

endsnippet

snippet mmcvprogressbar "mmcv progress bar" b

# def func(item):
# 	# do something
# 	pass
#
# tasks = [item_1, item_2, ..., item_n]

mmcv.track_progress(func, tasks)

mmcv.track_parallel_progress(func, tasks, 8)  # in parallel 8 workers

endsnippet

snippet argparse "argparse for python" b
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--<++>', default='<++>', type=<++>)
parser.add_argument('--<++>', action="store_true")
args=parser.parse_args()
endsnippet

snippet asynctask "asynctask example" b
import logging
import argparse
from pathlib import Path
from tqdm import tqdm
import pickle
import asyncio
import json

logger = logging.getLogger(__name__)


async def singletask(target_path: Path, failed: list):
    proc = await asyncio.create_subprocess_exec(
        'ffprobe', '-show_streams', '-select_streams', 'v', '-print_format', 'json', str(
            target_path),
        stdout=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await proc.communicate()
    if proc.returncode != 0:
        logger.error('cmd %s failed with return code %d',
                     target_path, proc.returncode)
        failed.append(target_path)
        return


async def main(args):
    input_dir: Path = args.input

    def search_files():
        yield from input_dir.glob('**/*.mp4')
        yield from input_dir.glob('**/*.avi')
    pending_targets = sorted(search_files())

    failed = list()
    tasks = set()
    with tqdm(total=len(pending_targets), smoothing=0.1) as progress:
        while True:
            while len(tasks) < args.jobs and pending_targets:
                target = pending_targets.pop()
                t = asyncio.create_task(singletask(target, failed))
                tasks.add(t)

            if not tasks:
                break

            done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
            for t in done:
                await t
                progress.update()

    print('The following failed in running: ')
    for p in failed:
        print(p.relative_to(input_dir))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-j', '--jobs', default=16, type=int)
    parser.add_argument('input', type=Path)

    args = parser.parse_args()

    asyncio.run(main(args))
endsnippet
